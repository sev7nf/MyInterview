http://blog.csdn.net/shenxiuwen1989/article/details/51777091
http://www.csdn.net/article/2012-05-28/2806046?locationNum=2
http://www.cnblogs.com/aigongsi/archive/2012/04/01/2429166.html
http://www.cnblogs.com/dolphin0520/p/3920373.html
http://blog.csdn.net/changtsing_liu/article/details/21551103
◆http://blog.csdn.net/lonelyroamer/article/details/7949969

普通线程、守护线程

转载地址：http://blog.csdn.net/lonelyroamer/article/details/7949969
      刚开始弄，感谢博主，侵删。
      
1、新建状态
用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态
（runnable）。
  注意：不能对已经启动的线程再次调用start()方法，否则会出现java.lang.IllegalThreadStateException异常。
2、就绪状态
处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列（尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为
cpu的调度不一定是按照先进先出的顺序来调度的），等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等
待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。
  提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。
3、运行状态
处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
处于就绪状态的线程，如果获得了cpu的调度，就会从就绪状态变为运行状态，执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就
绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。

当发生如下情况是，线程会从运行状态变为阻塞状态：
①、线程调用sleep方法主动放弃所占用的系统资源
②、线程调用一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
③、线程试图获得一个同步监视器，但更改同步监视器正被其他线程所持有
④、线程在等待某个通知（notify）
⑤、程序调用了线程的suspend方法将线程挂起。不过该方法容易导致死锁，所以程序应该尽量避免使用该方法。

当线程的run()方法执行完，或者被强制性地终止，例如出现异常，或者调用了stop()、desyory()方法等等，就会从运行状态转变为死亡状态。
4、阻塞状态
处于运行状态的线程在某些情况下，如执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。 
在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中
排队等待，被系统选中后从原来停止的位置开始继续运行。有三种方法可以暂停Threads执行：
5、死亡状态
当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能
复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。

